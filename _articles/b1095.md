---
layout: post
date: 2019-02-01 11:05:50 +0800
title:  "PAT Basic 1095. 解码PAT准考证 (C语言实现)"
categories: Basic
tags: [data processing]
permalink: Basic/1095.html
---

## 题目

PAT 准考证号由 4 部分组成：

  * 第 1 位是级别，即 `T` 代表顶级；`A` 代表甲级；`B` 代表乙级；
  * 第 2~4 位是考场编号，范围从 101 到 999；
  * 第 5~10 位是考试日期，格式为年、月、日顺次各占 2 位；
  * 最后 11~13 位是考生编号，范围从 000 到 999。

现给定一系列考生的准考证号和他们的成绩，请你按照要求输出各种统计信息。

### 输入格式：

输入首先在一行中给出两个正整数 $N$ （ $\le 10^4$ ）和 $M$ （ $\le 100$ ），分别为考生人数和统计要求的个数。

接下来 $N$ 行，每行给出一个考生的准考证号和其分数（在区间 $[0, 100]$ 内的整数），其间以空格分隔。

考生信息之后，再给出 $M$ 行，每行给出一个统计要求，格式为：`类型 指令`，其中

  * `类型` 为 1 表示要求按分数非升序输出某个指定级别的考生的成绩，对应的 `指令` 则给出代表指定级别的字母；
  * `类型` 为 2 表示要求将某指定考场的考生人数和总分统计输出，对应的 `指令` 则给出指定考场的编号；
  * `类型` 为 3 表示要求将某指定日期的考生人数分考场统计输出，对应的 `指令` 则给出指定日期，格式与准考证上日期相同。

### 输出格式：

对每项统计要求，首先在一行中输出 `Case #: 要求`，其中 `#` 是该项要求的编号，从 1 开始；`要求`
即复制输入给出的要求。随后输出相应的统计结果：

  * `类型` 为 1 的指令，输出格式与输入的考生信息格式相同，即 `准考证号 成绩`。对于分数并列的考生，按其准考证号的字典序递增输出（题目保证无重复准考证号）；
  * `类型` 为 2 的指令，按 `人数 总分` 的格式输出；
  * `类型` 为 3 的指令，输出按人数非递增顺序，格式为 `考场编号 总人数`。若人数并列则按考场编号递增顺序输出。

如果查询结果为空，则输出 `NA`。

### 输入样例：

    
    
    8 4
    B123180908127 99
    B102180908003 86
    A112180318002 98
    T107150310127 62
    A107180908108 100
    T123180908010 78
    B112160918035 88
    A107180908021 98
    1 A
    2 107
    3 180908
    2 999
    

### 输出样例：

    
    
    Case 1: 1 A
    A107180908108 100
    A107180908021 98
    A112180318002 98
    Case 2: 2 107
    3 260
    Case 3: 3 180908
    107 2
    123 2
    102 1
    Case 4: 2 999
    NA
    



## 思路


好久都没有通过，最后发现好像是排序出了问题（对，好像，因为我到现在还是不知道之前未通过的代码是出了什么问题）。

其实这类的题目没有什么太大难度，即使得不了满分也能拿到多半成绩。题目相当于三个小任务，逐个击破即可。

- 可用结构存储数据，便于管理。

- 1，读取后将数组按成绩降序，准考证号升序排序，然后将和要求级别一致的输出即可。

- 2，简单的计数求和。

- 3，可用int[1000]数组记录考场考生个数，利用数组索引代表考场号。最后注意输出考生数量递减，考场号递增即可

## 代码

[最新代码@github](https://github.com/OliverLew/PAT/blob/master/PATBasic/1095.c)，欢迎交流
```c
{% raw %}#include <stdio.h>
#include <string.h>
#include <stdlib.h>

typedef struct {
    char string[14];
    char level[2];  /* use 2-char array to avoid reading problems */
    int room;
    int date;
    int id;
    int score;
} Info;

int cmp(const void *a, const void *b)
{
    Info *ipa = (Info*)a;
    Info *ipb = (Info*)b;
    
    if(ipa->score != ipb->score)
        return ipb->score - ipa->score;
    return strcmp(ipa->string, ipb->string);
}

int main()
{
    int N, M, type, NAflag;
    Info info[10000];

    scanf("%d %d", &N, &M);
    for(int i = 0; i < N; i++)
    {
        scanf("%s %d", info[i].string,     &info[i].score);
        sscanf(info[i].string, "%1s%3d%6d%3d", info[i].level,
                &info[i].room,   &info[i].date,
                &info[i].id);
    }

    qsort(info, N, sizeof(Info), cmp);

    for(int i = 0; i < M; i++)
    {
        NAflag = 1;
        scanf("%d", &type);
        if(type == 1)
        {
            char level[2];
            scanf("%1s", level);
            printf("Case %d: %d %c\n", i + 1, type, level[0]);
            for(int j = 0; j < N; j++)
                if(info[j].level[0] == level[0])
                {
                    NAflag = 0;
                    printf("%c%03d%06d%03d %d\n", info[j].level[0],
                                  info[j].room,   info[j].date,
                                  info[j].id,     info[j].score);
                }
            if(NAflag)
                printf("NA\n");
        }
        else if(type == 2)
        {
            int room, sum = 0, count = 0;
            scanf("%d", &room);
            printf("Case %d: %d %d\n", i + 1, type, room);
            for(int j = 0; j < N; j++)
                if(info[j].room == room)
                {
                    NAflag = 0;
                    count++;
                    sum += info[j].score;
                }
            if(NAflag)
                printf("NA\n");
            else
                printf("%d %d\n", count, sum);
        }
        else if(type == 3)
        {
            int date, max = 0, rooms[1000] = {0};
            scanf("%d", &date);
            printf("Case %d: %d %06d\n", i + 1, type, date);
            for(int j = 0; j < N; j++)
                if(info[j].date == date)
                {
                    NAflag = 0;
                    rooms[info[j].room]++;
                    if(max < rooms[info[j].room])
                        max = rooms[info[j].room];
                }
            if(NAflag)
                printf("NA\n");
            else  /* print by count dec and room number inc */
                for(int c = max; c > 0; c--)
                    for(int r = 101; r < 1000; r++)
                        if(rooms[r] == c)
                            printf("%d %d\n", r, c);
        }
    }

    return 0;
}
{% endraw %}```